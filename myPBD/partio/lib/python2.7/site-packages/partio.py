# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_partio', [dirname(__file__)])
        except ImportError:
            import _partio
            return _partio
        if fp is not None:
            try:
                _mod = imp.load_module('_partio', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _partio = swig_import_helper()
    del swig_import_helper
else:
    import _partio
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



_partio.NONE_swigconstant(_partio)
NONE = _partio.NONE

_partio.VECTOR_swigconstant(_partio)
VECTOR = _partio.VECTOR

_partio.FLOAT_swigconstant(_partio)
FLOAT = _partio.FLOAT

_partio.INT_swigconstant(_partio)
INT = _partio.INT

_partio.INDEXEDSTR_swigconstant(_partio)
INDEXEDSTR = _partio.INDEXEDSTR
class ParticleAttribute(_object):
    """A handle for operating on attribbutes of a particle set"""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleAttribute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleAttribute, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _partio.ParticleAttribute_type_set
    __swig_getmethods__["type"] = _partio.ParticleAttribute_type_get
    if _newclass:
        type = _swig_property(_partio.ParticleAttribute_type_get, _partio.ParticleAttribute_type_set)
    __swig_setmethods__["count"] = _partio.ParticleAttribute_count_set
    __swig_getmethods__["count"] = _partio.ParticleAttribute_count_get
    if _newclass:
        count = _swig_property(_partio.ParticleAttribute_count_get, _partio.ParticleAttribute_count_set)
    __swig_setmethods__["name"] = _partio.ParticleAttribute_name_set
    __swig_getmethods__["name"] = _partio.ParticleAttribute_name_get
    if _newclass:
        name = _swig_property(_partio.ParticleAttribute_name_get, _partio.ParticleAttribute_name_set)

    def __init__(self):
        """
        __init__(ParticleAttribute self) -> ParticleAttribute

        Attribute name
        """
        this = _partio.new_ParticleAttribute()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _partio.delete_ParticleAttribute
    __del__ = lambda self: None
ParticleAttribute_swigregister = _partio.ParticleAttribute_swigregister
ParticleAttribute_swigregister(ParticleAttribute)

class ParticlesInfo(_object):
    """A set of particles with associated data attributes."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticlesInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParticlesInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def numParticles(self):
        """
        numParticles(ParticlesInfo self) -> int

        Returns the number of particles in the set
        """
        return _partio.ParticlesInfo_numParticles(self)


    def numAttributes(self):
        """
        numAttributes(ParticlesInfo self) -> int

        Returns the number of particles in the set
        """
        return _partio.ParticlesInfo_numAttributes(self)


    def numFixedAttributes(self):
        """
        numFixedAttributes(ParticlesInfo self) -> int

        Returns the number of fixed attributes
        """
        return _partio.ParticlesInfo_numFixedAttributes(self)


    def attributeInfo(self, *args):
        """
        attributeInfo(ParticlesInfo self, char const * name) -> ParticleAttribute
        attributeInfo(ParticlesInfo self, int const index) -> ParticleAttribute

        Returns the attribute handle by index
        """
        return _partio.ParticlesInfo_attributeInfo(self, *args)


    def fixedAttributeInfo(self, *args):
        """
        fixedAttributeInfo(ParticlesInfo self, char const * name) -> FixedAttribute
        fixedAttributeInfo(ParticlesInfo self, int const index) -> FixedAttribute *

        Returns the fixed attribute handle by index
        """
        return _partio.ParticlesInfo_fixedAttributeInfo(self, *args)

    __swig_destroy__ = _partio.delete_ParticlesInfo
    __del__ = lambda self: None
ParticlesInfo_swigregister = _partio.ParticlesInfo_swigregister
ParticlesInfo_swigregister(ParticlesInfo)

class ParticlesData(ParticlesInfo):
    """A reader for a set of particles."""

    __swig_setmethods__ = {}
    for _s in [ParticlesInfo]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticlesData, name, value)
    __swig_getmethods__ = {}
    for _s in [ParticlesInfo]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ParticlesData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def lookupIndexedStr(self, attribute, str):
        """
        lookupIndexedStr(ParticlesData self, ParticleAttribute attribute, char const * str) -> int

        Looks up a given indexed string given the index, returns -1 if not found
        """
        return _partio.ParticlesData_lookupIndexedStr(self, attribute, str)


    def lookupFixedIndexedStr(self, attribute, str):
        """
        lookupFixedIndexedStr(ParticlesData self, FixedAttribute const & attribute, char const * str) -> int

        Looks up a given fixed indexed string given the index, returns -1 if not found
        """
        return _partio.ParticlesData_lookupFixedIndexedStr(self, attribute, str)


    def findNPoints(self, center, nPoints, maxRadius):
        """
        findNPoints(ParticlesData self, fixedFloatArray center, int nPoints, float maxRadius) -> PyObject *

        Searches for the N nearest points to the center location
        or as many as can be found within maxRadius distance.
        """
        return _partio.ParticlesData_findNPoints(self, center, nPoints, maxRadius)


    def findPoints(self, bboxMin, bboxMax):
        """
        findPoints(ParticlesData self, fixedFloatArray bboxMin, fixedFloatArray bboxMax) -> PyObject *

        Returns the indices of all points within the bounding
        box defined by the two cube corners bboxMin and bboxMax
        """
        return _partio.ParticlesData_findPoints(self, bboxMin, bboxMax)


    def get(self, attr, particleIndex):
        """
        get(ParticlesData self, ParticleAttribute attr, ParticleIndex const particleIndex) -> PyObject *

        Gets attribute data for particleIndex'th particle
        """
        return _partio.ParticlesData_get(self, attr, particleIndex)


    def getFixed(self, attr):
        """
        getFixed(ParticlesData self, FixedAttribute const & attr) -> PyObject *

        Gets fixed attribute data
        """
        return _partio.ParticlesData_getFixed(self, attr)


    def indexedStrs(self, attr):
        """
        indexedStrs(ParticlesData self, ParticleAttribute attr) -> PyObject *

        Gets a list of all indexed strings for the given attribute handle
        """
        return _partio.ParticlesData_indexedStrs(self, attr)


    def fixedIndexedStrs(self, attr):
        """
        fixedIndexedStrs(ParticlesData self, FixedAttribute const & attr) -> PyObject *

        Gets a list of all indexed strings for the given fixed attribute handle
        """
        return _partio.ParticlesData_fixedIndexedStrs(self, attr)

    __swig_destroy__ = _partio.delete_ParticlesData
    __del__ = lambda self: None
ParticlesData_swigregister = _partio.ParticlesData_swigregister
ParticlesData_swigregister(ParticlesData)

class ParticleIteratorTrue(_object):
    """A reader for a set of particles."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleIteratorTrue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleIteratorTrue, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(ParticleIterator<(true)> self) -> ParticleIteratorTrue

        Creates a clustered particle set
        """
        this = _partio.new_ParticleIteratorTrue()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _partio.delete_ParticleIteratorTrue
    __del__ = lambda self: None
ParticleIteratorTrue_swigregister = _partio.ParticleIteratorTrue_swigregister
ParticleIteratorTrue_swigregister(ParticleIteratorTrue)

class ParticleIteratorFalse(_object):
    """A reader for a set of particles."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleIteratorFalse, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleIteratorFalse, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(ParticleIterator<(false)> self) -> ParticleIteratorFalse

        Creates a clustered particle set
        """
        this = _partio.new_ParticleIteratorFalse()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _partio.delete_ParticleIteratorFalse
    __del__ = lambda self: None
ParticleIteratorFalse_swigregister = _partio.ParticleIteratorFalse_swigregister
ParticleIteratorFalse_swigregister(ParticleIteratorFalse)

class ParticlesDataMutable(ParticlesData):
    """A writer for a set of particles."""

    __swig_setmethods__ = {}
    for _s in [ParticlesData]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticlesDataMutable, name, value)
    __swig_getmethods__ = {}
    for _s in [ParticlesData]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ParticlesDataMutable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def registerIndexedStr(self, attribute, str):
        """
        registerIndexedStr(ParticlesDataMutable self, ParticleAttribute attribute, char const * str) -> int

        Registers a string in the particular attribute
        """
        return _partio.ParticlesDataMutable_registerIndexedStr(self, attribute, str)


    def registerFixedIndexedStr(self, attribute, str):
        """
        registerFixedIndexedStr(ParticlesDataMutable self, FixedAttribute const & attribute, char const * str) -> int

        Registers a string in the particular fixed attribute
        """
        return _partio.ParticlesDataMutable_registerFixedIndexedStr(self, attribute, str)


    def setIndexedStr(self, attribute, particleAttributeHandle, str):
        """
        setIndexedStr(ParticlesDataMutable self, ParticleAttribute attribute, int particleAttributeHandle, char const * str)

        Changes a given index's associated string (for all particles that use this index too)
        """
        return _partio.ParticlesDataMutable_setIndexedStr(self, attribute, particleAttributeHandle, str)


    def setFixedIndexedStr(self, attribute, particleAttributeHandle, str):
        """
        setFixedIndexedStr(ParticlesDataMutable self, FixedAttribute const & attribute, int particleAttributeHandle, char const * str)

        Changes a given fixed index's associated string
        """
        return _partio.ParticlesDataMutable_setFixedIndexedStr(self, attribute, particleAttributeHandle, str)


    def sort(self):
        """
        sort(ParticlesDataMutable self)

        Prepares data for N nearest neighbor searches using the
        attribute in the file with name 'position'
        """
        return _partio.ParticlesDataMutable_sort(self)


    def addAttribute(self, attribute, type, count):
        """
        addAttribute(ParticlesDataMutable self, char const * attribute, ParticleAttributeType type, int const count) -> ParticleAttribute

        Adds a new attribute of given name, type and count. If type is
        partio.VECTOR, then count must be 3
        """
        return _partio.ParticlesDataMutable_addAttribute(self, attribute, type, count)


    def addFixedAttribute(self, attribute, type, count):
        """
        addFixedAttribute(ParticlesDataMutable self, char const * attribute, ParticleAttributeType type, int const count) -> FixedAttribute

        Adds a new fixed attribute of given name, type and count. If type is
        partio.VECTOR, then count must be 3
        """
        return _partio.ParticlesDataMutable_addFixedAttribute(self, attribute, type, count)


    def addParticle(self):
        """
        addParticle(ParticlesDataMutable self) -> ParticleIndex

        Adds a new particle and returns the index
        """
        return _partio.ParticlesDataMutable_addParticle(self)


    def addParticles(self, count):
        """
        addParticles(ParticlesDataMutable self, int const count) -> ParticleIteratorFalse

        Adds count particles and returns the offset to the first one
        """
        return _partio.ParticlesDataMutable_addParticles(self, count)


    def set(self, attr, particleIndex, tuple):
        """
        set(ParticlesDataMutable self, ParticleAttribute attr, uint64_t const particleIndex, PyObject * tuple) -> PyObject *

        Sets data on a given attribute for a single particle.
        Data must be specified as tuple.
        """
        return _partio.ParticlesDataMutable_set(self, attr, particleIndex, tuple)


    def setFixed(self, attr, tuple):
        """
        setFixed(ParticlesDataMutable self, FixedAttribute const & attr, PyObject * tuple) -> PyObject *

        Sets data on a given fixed attribute.
        Data must be specified as tuple.
        """
        return _partio.ParticlesDataMutable_setFixed(self, attr, tuple)

    __swig_destroy__ = _partio.delete_ParticlesDataMutable
    __del__ = lambda self: None
ParticlesDataMutable_swigregister = _partio.ParticlesDataMutable_swigregister
ParticlesDataMutable_swigregister(ParticlesDataMutable)


def create():
    """
    create() -> ParticlesDataMutable

    Create an empty particle array
    """
    return _partio.create()

def read(*args):
    """
    read(char const * filename, bool verbose=True, std::ostream & error) -> ParticlesDataMutable
    read(char const * filename, bool verbose=True) -> ParticlesDataMutable
    read(char const * filename) -> ParticlesDataMutable

    Reads a particle set from disk
    """
    return _partio.read(*args)

def readVerbose(filename):
    """
    readVerbose(char const * filename) -> PyObject *

    Reads a particle set from disk and returns the tuple particleObject,errorMsg
    """
    return _partio.readVerbose(filename)

def readHeadersVerbose(filename):
    """
    readHeadersVerbose(char const * filename) -> PyObject *

    Reads the header/attribute information from disk and returns the tuple particleObject,errorMsg
    """
    return _partio.readHeadersVerbose(filename)

def readCachedVerbose(filename, sort):
    """
    readCachedVerbose(char const * filename, bool sort) -> PyObject *

    Reads the header/attribute information from disk and returns the tuple particleObject,errorMsg
    """
    return _partio.readCachedVerbose(filename, sort)

def readHeaders(*args):
    """
    readHeaders(char const * filename, bool verbose=True, std::ostream & error) -> ParticlesInfo
    readHeaders(char const * filename, bool verbose=True) -> ParticlesInfo
    readHeaders(char const * filename) -> ParticlesInfo

    Reads a particle set headers from disk
    """
    return _partio.readHeaders(*args)

def write(filename, arg2, arg3=False):
    """
    write(char const * filename, ParticlesData arg2, bool const arg3=False)
    write(char const * filename, ParticlesData arg2)

    Writes a particle set to disk
    """
    return _partio.write(filename, arg2, arg3)

def _print(particles):
    """
    _print(ParticlesData particles)

    Print a summary of particle file
    """
    return _partio._print(particles)

def computeClustering(particles, numNeighbors, radiusSearch, radiusInside, connections, density):
    """
    computeClustering(ParticlesDataMutable particles, int const numNeighbors, double const radiusSearch, double const radiusInside, int const connections, double const density) -> ParticlesDataMutable

    Creates a clustered particle set
    """
    return _partio.computeClustering(particles, numNeighbors, radiusSearch, radiusInside, connections, density)
# This file is compatible with both classic and new-style classes.


